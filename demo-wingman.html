<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wingman Support System - Team Special Demo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0a0a1a;
      color: #e0e0e0;
      overflow-x: hidden;
    }
    
    .demo-container {
      width: 100%;
      min-height: 100vh;
    }
    
    #game-canvas {
      width: 100%;
      height: 70vh;
      min-height: 500px;
      background: #000011;
      position: relative;
    }
    
    /* HUD Overlay */
    #hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      font-family: 'Courier New', monospace;
      color: #00ff88;
      text-shadow: 0 0 10px #00ff88;
    }
    
    .hud-title {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 18px;
      text-align: center;
    }
    
    .hud-wingman-status {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 14px;
    }
    
    .hud-enemy-count {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 14px;
    }
    
    .hud-cooldown {
      position: absolute;
      bottom: 150px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }
    
    .hud-cooldown .label {
      font-size: 14px;
      margin-bottom: 8px;
    }
    
    .hud-cooldown .bar-container {
      width: 250px;
      height: 12px;
      border: 2px solid #00ff88;
      position: relative;
    }
    
    .hud-cooldown .bar-fill {
      height: 100%;
      transition: width 0.1s, background 0.2s;
    }
    
    .hud-message {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 32px;
      text-align: center;
      opacity: 0;
      transition: opacity 0.3s;
      text-shadow: 0 0 20px currentColor;
    }
    
    .hud-message.visible {
      opacity: 1;
    }
    
    .hud-attack-type {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, 20px);
      font-size: 16px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .hud-attack-type.visible {
      opacity: 0.8;
    }
    
    /* Wingman Selector */
    .wingman-selector {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      pointer-events: auto;
    }
    
    .selector-buttons {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
    }
    
    .wingman-btn {
      padding: 12px 20px;
      background: transparent;
      border: 2px solid;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 100px;
    }
    
    .wingman-btn:hover:not(:disabled) {
      transform: scale(1.05);
    }
    
    .wingman-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    
    .wingman-btn.selected {
      color: #000 !important;
    }
    
    .wingman-btn[data-wingman="0"] {
      border-color: #ff4444;
      color: #ff4444;
    }
    .wingman-btn[data-wingman="0"].selected {
      background: #ff4444;
    }
    
    .wingman-btn[data-wingman="1"] {
      border-color: #44ff44;
      color: #44ff44;
    }
    .wingman-btn[data-wingman="1"].selected {
      background: #44ff44;
    }
    
    .wingman-btn[data-wingman="2"] {
      border-color: #ffff44;
      color: #ffff44;
    }
    .wingman-btn[data-wingman="2"].selected {
      background: #ffff44;
    }
    
    .wingman-btn[data-wingman="3"] {
      border-color: #ff44ff;
      color: #ff44ff;
    }
    .wingman-btn[data-wingman="3"].selected {
      background: #ff44ff;
    }
    
    .trigger-btn {
      padding: 15px 40px;
      background: linear-gradient(180deg, #00aa66 0%, #006644 100%);
      border: 2px solid #00ff88;
      color: #00ff88;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      text-shadow: 0 0 10px #00ff88;
    }
    
    .trigger-btn:hover:not(:disabled) {
      background: linear-gradient(180deg, #00cc77 0%, #008855 100%);
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
      transform: scale(1.05);
    }
    
    .trigger-btn:disabled {
      background: #333;
      border-color: #666;
      color: #666;
      cursor: not-allowed;
      text-shadow: none;
    }
    
    .reset-btn {
      position: absolute;
      bottom: 20px;
      right: 20px;
      padding: 10px 20px;
      background: transparent;
      border: 2px solid #4488ff;
      color: #4488ff;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      cursor: pointer;
      pointer-events: auto;
    }
    
    .reset-btn:hover {
      background: #4488ff;
      color: #000;
    }
    
    .attack-hint {
      font-size: 11px;
      opacity: 0.7;
      margin-top: 5px;
    }
    
    /* Info panel */
    .info-panel {
      padding: 30px;
      background: linear-gradient(180deg, #0d0d20 0%, #0a0a1a 100%);
      border-top: 1px solid #1a1a3a;
    }
    
    .info-panel h1 {
      font-size: 2em;
      color: #00ff88;
      text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
      margin-bottom: 10px;
    }
    
    .info-panel h2 {
      font-size: 1.3em;
      color: #4488ff;
      margin: 25px 0 15px 0;
      border-bottom: 1px solid #2a2a4a;
      padding-bottom: 8px;
    }
    
    .subtitle {
      color: #888;
      font-size: 1.1em;
      margin-bottom: 25px;
    }
    
    .wingman-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }
    
    .wingman-card {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid #2a2a4a;
      border-radius: 8px;
      padding: 20px;
      transition: all 0.3s ease;
    }
    
    .wingman-card:hover {
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.05);
    }
    
    .wingman-card.falco { border-left: 4px solid #ff4444; }
    .wingman-card.slippy { border-left: 4px solid #44ff44; }
    .wingman-card.peppy { border-left: 4px solid #ffff44; }
    .wingman-card.krystal { border-left: 4px solid #ff44ff; }
    
    .wingman-card h3 {
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .wingman-card.falco h3 { color: #ff4444; }
    .wingman-card.slippy h3 { color: #44ff44; }
    .wingman-card.peppy h3 { color: #ffff44; }
    .wingman-card.krystal h3 { color: #ff44ff; }
    
    .wingman-card p {
      color: #aaa;
      line-height: 1.6;
      font-size: 0.95em;
    }
    
    .attack-name {
      font-size: 0.8em;
      padding: 3px 8px;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.1);
    }
    
    .config-section {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
    }
    
    .config-section pre {
      background: #0d0d1a;
      border: 1px solid #2a2a4a;
      border-radius: 4px;
      padding: 15px;
      overflow-x: auto;
      font-size: 13px;
      line-height: 1.5;
    }
    
    .config-section code {
      color: #88ccff;
    }
    
    .feature-list {
      list-style: none;
      padding: 0;
    }
    
    .feature-list li {
      padding: 8px 0;
      padding-left: 25px;
      position: relative;
      color: #ccc;
    }
    
    .feature-list li::before {
      content: 'â–¹';
      position: absolute;
      left: 0;
      color: #00ff88;
    }
  </style>
</head>
<body>
  <div class="demo-container">
    <div id="game-canvas">
      <div id="hud">
        <div class="hud-title">WINGMAN SUPPORT SYSTEM - TEAM SPECIAL DEMO</div>
        
        <div class="hud-wingman-status">
          <div>WINGMAN: <span id="wingman-name">FALCO</span></div>
          <div>STATUS: <span id="wingman-status">STANDING BY</span></div>
        </div>
        
        <div class="hud-enemy-count">
          ENEMIES: <span id="enemy-count">8</span>
        </div>
        
        <div class="hud-cooldown">
          <div class="label" id="cooldown-label">TEAM SPECIAL [READY]</div>
          <div class="bar-container">
            <div class="bar-fill" id="cooldown-bar" style="width: 100%; background: #00ff88;"></div>
          </div>
        </div>
        
        <div class="hud-message" id="hud-message"></div>
        <div class="hud-attack-type" id="hud-attack-type"></div>
        
        <div class="wingman-selector">
          <div class="selector-buttons">
            <button class="wingman-btn selected" data-wingman="0">FALCO</button>
            <button class="wingman-btn" data-wingman="1">SLIPPY</button>
            <button class="wingman-btn" data-wingman="2">PEPPY</button>
            <button class="wingman-btn" data-wingman="3">KRYSTAL</button>
          </div>
          <button class="trigger-btn" id="trigger-btn">CALL TEAM SPECIAL</button>
          <div class="attack-hint" id="attack-hint">MULTI-GATLING GUNS</div>
        </div>
        
        <button class="reset-btn" id="reset-btn">RESET ENEMIES</button>
      </div>
    </div>
    
    <div class="info-panel">
      <h1>Wingman Support System</h1>
      <p class="subtitle">Team Special ability component for Starfox 64 inspired tunnel shooter</p>
      
      <h2>Overview</h2>
      <p>The Team Special is a powerful support ability with a 45-second cooldown. When triggered, your selected wingman flies in from behind, executes their signature attack that eliminates all enemies on screen, then escapes by climbing away.</p>
      
      <ul class="feature-list">
        <li>45-second cooldown between uses</li>
        <li>4 unique wingmen with different attack styles</li>
        <li>Wingman ships have no collision during flyby</li>
        <li>All attacks guarantee enemy elimination</li>
        <li>Dramatic visual effects for each attack type</li>
      </ul>
      
      <h2>Wingman Roster</h2>
      <div class="wingman-grid">
        <div class="wingman-card falco">
          <h3>FALCO <span class="attack-name">Multi-Gatling Guns</span></h3>
          <p>Performs a strafing run with rapid-fire gatling guns. Fires a barrage of projectiles at all enemies simultaneously. Each enemy receives multiple hits ensuring destruction. Best for visual spectacle with lots of projectiles filling the screen.</p>
        </div>
        
        <div class="wingman-card slippy">
          <h3>SLIPPY <span class="attack-name">Multi-Beam Guns</span></h3>
          <p>Fires precision beam weapons at each enemy. Each beam locks on and eliminates its target after 0.1 seconds of contact. Clean, efficient, and devastating. The beams visually connect Slippy's ship to each target.</p>
        </div>
        
        <div class="wingman-card peppy">
          <h3>PEPPY <span class="attack-name">Lightning Gun</span></h3>
          <p>Unleashes a chain lightning attack that arcs between all enemies with unlimited range. The lightning chains from enemy to enemy before they all explode simultaneously. Creates a spectacular electrical web effect.</p>
        </div>
        
        <div class="wingman-card krystal">
          <h3>KRYSTAL <span class="attack-name">Precision Swarm</span></h3>
          <p>Launches a swarm of homing missiles - one per enemy. All missiles fire simultaneously and track their targets with perfect accuracy. Missiles follow arcing trajectories before impact.</p>
        </div>
      </div>
      
      <h2>Integration Example</h2>
      <div class="config-section">
        <pre><code>import { WingmanSupport, WingmanSelectorHUD, WINGMAN_CONFIG } from './WingmanSupport';

function GameScene() {
  const [selectedWingman, setSelectedWingman] = useState(0);
  const [cooldown, setCooldown] = useState(0);
  const [enemies, setEnemies] = useState([...]);
  
  const handleEnemiesDestroyed = (enemyIds) => {
    setEnemies(prev => prev.filter(e => !enemyIds.includes(e.id)));
    // Award points, update score, etc.
  };
  
  return (
    &lt;Canvas&gt;
      {/* Your game components */}
      &lt;PlayerController /&gt;
      &lt;EnemyManager enemies={enemies} /&gt;
      
      {/* Wingman Support System */}
      &lt;WingmanSupport
        playerPosition={playerPosition}
        playerForward={playerForward}
        enemies={enemies}
        selectedWingman={selectedWingman}
        onEnemiesDestroyed={handleEnemiesDestroyed}
        onCooldownUpdate={(current, max) => setCooldown(current)}
      /&gt;
      
      {/* HUD - rendered in Html component */}
      &lt;Html&gt;
        &lt;WingmanSelectorHUD
          selectedWingman={selectedWingman}
          onSelect={setSelectedWingman}
          cooldown={cooldown}
          maxCooldown={WINGMAN_CONFIG.TEAM_SPECIAL_COOLDOWN}
        /&gt;
      &lt;/Html&gt;
    &lt;/Canvas&gt;
  );
}</code></pre>
      </div>
      
      <h2>Configuration</h2>
      <div class="config-section">
        <pre><code>const WINGMAN_CONFIG = {
  // Cooldown
  TEAM_SPECIAL_COOLDOWN: 45000,  // 45 seconds

  // Wingman Ship Movement
  SPAWN_OFFSET_BEHIND: 40,
  SPAWN_OFFSET_ABOVE: 15,
  APPROACH_SPEED: 60,
  ATTACK_DURATION: 2000,
  ESCAPE_DURATION: 1500,
  ESCAPE_CLIMB_ANGLE: 0.8,
  
  // Attack Timings
  GATLING_FIRE_DURATION: 800,
  BEAM_LOCK_DURATION: 100,      // 0.1 seconds
  LIGHTNING_CHAIN_DURATION: 600,
  MISSILE_FLIGHT_TIME: 500,
};</code></pre>
      </div>
      
      <h2>Exported Components</h2>
      <div class="config-section">
        <pre><code>// Default export - complete system
export default WingmanSupportSystem;

// Named exports for custom integration
export {
  WingmanSupport,      // Core wingman logic
  WingmanShip,         // Ship visual component
  WingmanSelectorHUD,  // Selection UI
  GatlingProjectile,   // Gatling attack projectiles
  BeamEffect,          // Beam attack visual
  LightningChain,      // Lightning chain effect
  Missile,             // Missile projectile
  Explosion,           // Explosion effect
  WINGMAN_CONFIG,      // Configuration constants
};</code></pre>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ========================================================================
    // WINGMAN SUPPORT DEMO - THREE.JS IMPLEMENTATION
    // ========================================================================
    
    const WINGMAN_CONFIG = {
      TEAM_SPECIAL_COOLDOWN: 45000,
      SPAWN_OFFSET_BEHIND: 40,
      SPAWN_OFFSET_ABOVE: 15,
      ATTACK_DURATION: 2000,
      ESCAPE_DURATION: 1500,
      ESCAPE_CLIMB_ANGLE: 0.8,
      GATLING_FIRE_DURATION: 800,
      BEAM_LOCK_DURATION: 100,
      LIGHTNING_CHAIN_DURATION: 600,
      MISSILE_FLIGHT_TIME: 500,
      
      WINGMAN_COLORS: [0xff4444, 0x44ff44, 0xffff44, 0xff44ff],
      WINGMAN_NAMES: ['FALCO', 'SLIPPY', 'PEPPY', 'KRYSTAL'],
      ATTACK_NAMES: ['MULTI-GATLING GUNS', 'MULTI-BEAM GUNS', 'LIGHTNING GUN', 'PRECISION SWARM'],
    };
    
    class WingmanDemo {
      constructor(container) {
        this.container = container;
        this.selectedWingman = 0;
        this.cooldown = 0;
        this.isActive = false;
        this.phase = 'idle';
        this.enemies = [];
        this.effects = [];
        this.explosions = [];
        this.wingmanMesh = null;
        this.phaseStartTime = 0;
        this.attackPosition = new THREE.Vector3();
        
        this.init();
        this.createScene();
        this.createPlayer();
        this.resetEnemies();
        this.setupEventListeners();
        this.animate();
      }
      
      init() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000011);
        this.scene.fog = new THREE.Fog(0x000022, 30, 150);
        
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;
        
        this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
        this.camera.position.set(0, 8, 25);
        this.camera.lookAt(0, 0, -20);
        
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(width, height);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.container.insertBefore(this.renderer.domElement, this.container.firstChild);
        
        this.lastTime = performance.now();
        
        window.addEventListener('resize', () => this.onResize());
      }
      
      createScene() {
        // Lighting
        const ambient = new THREE.AmbientLight(0x404060, 0.5);
        this.scene.add(ambient);
        
        const directional = new THREE.DirectionalLight(0xffffff, 0.8);
        directional.position.set(10, 20, 10);
        this.scene.add(directional);
        
        // Ground plane
        const groundGeo = new THREE.PlaneGeometry(200, 200, 20, 20);
        const groundMat = new THREE.MeshStandardMaterial({
          color: 0x112233,
          wireframe: true,
          transparent: true,
          opacity: 0.3,
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -5;
        this.scene.add(ground);
        
        // Starfield
        const starGeo = new THREE.BufferGeometry();
        const starPositions = [];
        for (let i = 0; i < 500; i++) {
          starPositions.push(
            (Math.random() - 0.5) * 200,
            Math.random() * 100,
            (Math.random() - 0.5) * 200 - 50
          );
        }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
        const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5 });
        const stars = new THREE.Points(starGeo, starMat);
        this.scene.add(stars);
      }
      
      createPlayer() {
        this.playerGroup = new THREE.Group();
        
        // Main body
        const bodyGeo = new THREE.BoxGeometry(1.5, 0.5, 2);
        const bodyMat = new THREE.MeshStandardMaterial({
          color: 0x4488ff,
          emissive: 0x112244,
          metalness: 0.8,
          roughness: 0.2,
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        this.playerGroup.add(body);
        
        // Wings
        const wingGeo = new THREE.BoxGeometry(1.5, 0.1, 1);
        const wingMat = new THREE.MeshStandardMaterial({
          color: 0x3366cc,
          metalness: 0.8,
          roughness: 0.2,
        });
        
        const leftWing = new THREE.Mesh(wingGeo, wingMat);
        leftWing.position.set(-1.5, 0, 0);
        this.playerGroup.add(leftWing);
        
        const rightWing = new THREE.Mesh(wingGeo, wingMat);
        rightWing.position.set(1.5, 0, 0);
        this.playerGroup.add(rightWing);
        
        // Engine
        const engineGeo = new THREE.ConeGeometry(0.3, 0.8, 8);
        const engineMat = new THREE.MeshBasicMaterial({ color: 0xff8800 });
        const engine = new THREE.Mesh(engineGeo, engineMat);
        engine.position.set(0, 0, 1.2);
        this.playerGroup.add(engine);
        
        const engineLight = new THREE.PointLight(0xff8800, 2, 4);
        engineLight.position.set(0, 0, 1.5);
        this.playerGroup.add(engineLight);
        
        this.playerGroup.rotation.y = Math.PI;
        this.scene.add(this.playerGroup);
      }
      
      createEnemy(x, y, z) {
        const group = new THREE.Group();
        
        const bodyGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
        const bodyMat = new THREE.MeshStandardMaterial({
          color: 0xff2222,
          emissive: 0x440000,
          metalness: 0.5,
          roughness: 0.5,
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        group.add(body);
        
        // Eye/sensor
        const eyeGeo = new THREE.SphereGeometry(0.3, 8, 8);
        const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const eye = new THREE.Mesh(eyeGeo, eyeMat);
        eye.position.z = 0.6;
        group.add(eye);
        
        const eyeLight = new THREE.PointLight(0xffff00, 1, 3);
        eyeLight.position.z = 0.7;
        group.add(eyeLight);
        
        group.position.set(x, y, z);
        group.userData = { id: Math.random().toString(36).substr(2, 9) };
        
        this.scene.add(group);
        this.enemies.push(group);
        
        return group;
      }
      
      resetEnemies() {
        // Remove existing enemies
        this.enemies.forEach(enemy => {
          this.scene.remove(enemy);
        });
        this.enemies = [];
        
        // Create new enemy formation
        const positions = [
          [-8, 2, -30], [-4, 4, -35], [0, 2, -32], [4, 4, -35], [8, 2, -30],
          [-6, 0, -40], [0, -1, -42], [6, 0, -40],
        ];
        
        positions.forEach(([x, y, z]) => {
          this.createEnemy(x, y, z);
        });
        
        this.updateEnemyCount();
      }
      
      createWingmanShip() {
        if (this.wingmanMesh) {
          this.scene.remove(this.wingmanMesh);
        }
        
        const color = WINGMAN_CONFIG.WINGMAN_COLORS[this.selectedWingman];
        
        this.wingmanMesh = new THREE.Group();
        
        // Main body
        const bodyGeo = new THREE.BoxGeometry(1.2, 0.4, 1.8);
        const bodyMat = new THREE.MeshStandardMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.3,
          metalness: 0.8,
          roughness: 0.2,
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        this.wingmanMesh.add(body);
        
        // Wings
        const wingGeo = new THREE.BoxGeometry(1.2, 0.08, 0.8);
        const wingMat = new THREE.MeshStandardMaterial({
          color: color,
          metalness: 0.8,
          roughness: 0.2,
        });
        
        const leftWing = new THREE.Mesh(wingGeo, wingMat);
        leftWing.position.set(-1.2, 0, 0);
        this.wingmanMesh.add(leftWing);
        
        const rightWing = new THREE.Mesh(wingGeo, wingMat);
        rightWing.position.set(1.2, 0, 0);
        this.wingmanMesh.add(rightWing);
        
        // Engine
        const engineGeo = new THREE.ConeGeometry(0.25, 1.5, 8);
        const engineMat = new THREE.MeshBasicMaterial({ color: 0xff8800 });
        const engine = new THREE.Mesh(engineGeo, engineMat);
        engine.position.set(0, 0, 1);
        this.wingmanMesh.add(engine);
        
        const engineLight = new THREE.PointLight(0xff8800, 3, 5);
        engineLight.position.set(0, 0, 1.2);
        this.wingmanMesh.add(engineLight);
        
        // ID light
        const idLight = new THREE.PointLight(color, 2, 8);
        idLight.position.set(0, 0.5, 0);
        this.wingmanMesh.add(idLight);
        
        this.wingmanMesh.visible = false;
        this.scene.add(this.wingmanMesh);
      }
      
      triggerTeamSpecial() {
        if (this.cooldown > 0 || this.isActive || this.enemies.length === 0) return;
        
        this.isActive = true;
        this.phase = 'approach';
        this.phaseStartTime = performance.now();
        
        this.createWingmanShip();
        this.wingmanMesh.visible = true;
        
        // Spawn position
        const spawnPos = new THREE.Vector3(0, WINGMAN_CONFIG.SPAWN_OFFSET_ABOVE, WINGMAN_CONFIG.SPAWN_OFFSET_BEHIND);
        this.wingmanMesh.position.copy(spawnPos);
        this.wingmanMesh.rotation.y = Math.PI;
        
        // Attack position
        this.attackPosition.set(5, 2, 0);
        
        // Show message
        this.showMessage(`${WINGMAN_CONFIG.WINGMAN_NAMES[this.selectedWingman]} INCOMING!`, 0xffffff);
        this.showAttackType(WINGMAN_CONFIG.ATTACK_NAMES[this.selectedWingman]);
        
        this.updateStatus('APPROACHING');
      }
      
      executeAttack() {
        const shipPos = this.attackPosition.clone();
        
        switch (this.selectedWingman) {
          case 0: this.executeGatlingAttack(shipPos); break;
          case 1: this.executeBeamAttack(shipPos); break;
          case 2: this.executeLightningAttack(shipPos); break;
          case 3: this.executeMissileAttack(shipPos); break;
        }
      }
      
      executeGatlingAttack(shipPos) {
        this.enemies.forEach((enemy, i) => {
          for (let j = 0; j < 5; j++) {
            const delay = j * 50 + i * 30;
            setTimeout(() => {
              if (this.enemies.includes(enemy)) {
                this.createGatlingProjectile(
                  shipPos.clone().add(new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 1,
                    0
                  )),
                  enemy.position.clone(),
                  enemy
                );
              }
            }, delay);
          }
        });
      }
      
      createGatlingProjectile(start, target, enemy) {
        const geo = new THREE.SphereGeometry(0.2, 6, 6);
        const mat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
        const projectile = new THREE.Mesh(geo, mat);
        projectile.position.copy(start);
        
        const light = new THREE.PointLight(0xffaa00, 1, 3);
        projectile.add(light);
        
        this.scene.add(projectile);
        
        const direction = new THREE.Vector3().subVectors(target, start).normalize();
        const speed = 120;
        
        this.effects.push({
          type: 'gatling',
          mesh: projectile,
          direction: direction,
          speed: speed,
          target: target,
          enemy: enemy,
        });
      }
      
      executeBeamAttack(shipPos) {
        this.enemies.forEach((enemy, i) => {
          setTimeout(() => {
            if (this.enemies.includes(enemy)) {
              this.createBeam(shipPos.clone(), enemy.position.clone(), enemy);
            }
          }, i * 50);
        });
      }
      
      createBeam(start, end, enemy) {
        const midPoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
        const length = start.distanceTo(end);
        const direction = new THREE.Vector3().subVectors(end, start).normalize();
        
        // Create beam group
        const beamGroup = new THREE.Group();
        
        // Core beam
        const coreGeo = new THREE.CylinderGeometry(0.15, 0.15, length, 8);
        const coreMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.9 });
        const core = new THREE.Mesh(coreGeo, coreMat);
        beamGroup.add(core);
        
        // Outer glow
        const glowGeo = new THREE.CylinderGeometry(0.4, 0.4, length, 8);
        const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.3 });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        beamGroup.add(glow);
        
        // Light
        const light = new THREE.PointLight(0x00ff88, 5, 15);
        beamGroup.add(light);
        
        beamGroup.position.copy(midPoint);
        
        // Rotate to point at target
        beamGroup.lookAt(end);
        beamGroup.rotateX(Math.PI / 2);
        
        this.scene.add(beamGroup);
        
        this.effects.push({
          type: 'beam',
          mesh: beamGroup,
          startTime: performance.now(),
          duration: WINGMAN_CONFIG.BEAM_LOCK_DURATION,
          enemy: enemy,
        });
      }
      
      executeLightningAttack(shipPos) {
        if (this.enemies.length === 0) return;
        
        // Sort enemies by distance
        const sortedEnemies = [...this.enemies].sort((a, b) => 
          shipPos.distanceTo(a.position) - shipPos.distanceTo(b.position)
        );
        
        const positions = [shipPos.clone()];
        sortedEnemies.forEach(enemy => positions.push(enemy.position.clone()));
        
        this.createLightningChain(positions, sortedEnemies);
      }
      
      createLightningChain(positions, targetEnemies) {
        const chainGroup = new THREE.Group();
        
        // Create jagged lightning between each pair of positions
        for (let i = 0; i < positions.length - 1; i++) {
          const start = positions[i];
          const end = positions[i + 1];
          const points = this.generateLightningPoints(start, end);
          
          for (let j = 0; j < points.length - 1; j++) {
            const segStart = points[j];
            const segEnd = points[j + 1];
            const mid = new THREE.Vector3().addVectors(segStart, segEnd).multiplyScalar(0.5);
            const len = segStart.distanceTo(segEnd);
            
            const geo = new THREE.CylinderGeometry(0.08, 0.08, len, 4);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffff88 });
            const segment = new THREE.Mesh(geo, mat);
            
            segment.position.copy(mid);
            segment.lookAt(segEnd);
            segment.rotateX(Math.PI / 2);
            
            chainGroup.add(segment);
          }
        }
        
        // Add glow at each node
        positions.forEach(pos => {
          const light = new THREE.PointLight(0xffff00, 3, 8);
          light.position.copy(pos);
          chainGroup.add(light);
        });
        
        this.scene.add(chainGroup);
        
        this.effects.push({
          type: 'lightning',
          mesh: chainGroup,
          startTime: performance.now(),
          duration: WINGMAN_CONFIG.LIGHTNING_CHAIN_DURATION,
          enemies: targetEnemies,
        });
      }
      
      generateLightningPoints(start, end) {
        const points = [start.clone()];
        const segments = 8;
        const direction = new THREE.Vector3().subVectors(end, start);
        const length = direction.length();
        direction.normalize();
        
        for (let i = 1; i < segments; i++) {
          const t = i / segments;
          const basePoint = start.clone().add(direction.clone().multiplyScalar(length * t));
          basePoint.add(new THREE.Vector3(
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 2
          ));
          points.push(basePoint);
        }
        points.push(end.clone());
        return points;
      }
      
      executeMissileAttack(shipPos) {
        this.enemies.forEach((enemy, i) => {
          this.createMissile(
            shipPos.clone().add(new THREE.Vector3(
              (i % 3 - 1) * 1.5,
              Math.floor(i / 3) * 0.5,
              0
            )),
            enemy.position.clone(),
            enemy
          );
        });
      }
      
      createMissile(start, target, enemy) {
        const group = new THREE.Group();
        
        // Missile body
        const bodyGeo = new THREE.ConeGeometry(0.2, 0.8, 6);
        const bodyMat = new THREE.MeshStandardMaterial({
          color: 0xff44ff,
          emissive: 0xff44ff,
          emissiveIntensity: 0.5,
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.rotation.x = Math.PI / 2;
        group.add(body);
        
        // Trail
        const trailGeo = new THREE.ConeGeometry(0.15, 0.6, 6);
        const trailMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.7 });
        const trail = new THREE.Mesh(trailGeo, trailMat);
        trail.rotation.x = Math.PI / 2;
        trail.position.z = 0.5;
        group.add(trail);
        
        // Light
        const light = new THREE.PointLight(0xff8800, 2, 4);
        light.position.z = 0.3;
        group.add(light);
        
        group.position.copy(start);
        this.scene.add(group);
        
        this.effects.push({
          type: 'missile',
          mesh: group,
          startPosition: start.clone(),
          target: target,
          enemy: enemy,
          startTime: performance.now(),
          flightTime: WINGMAN_CONFIG.MISSILE_FLIGHT_TIME,
        });
      }
      
      createExplosion(position, color = 0xff8800) {
        const group = new THREE.Group();
        
        const geo = new THREE.SphereGeometry(1, 16, 16);
        const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 1 });
        const sphere = new THREE.Mesh(geo, mat);
        group.add(sphere);
        
        const light = new THREE.PointLight(color, 10, 10);
        group.add(light);
        
        group.position.copy(position);
        this.scene.add(group);
        
        this.explosions.push({
          mesh: group,
          material: mat,
          light: light,
          startTime: performance.now(),
          duration: 500,
        });
      }
      
      destroyEnemy(enemy) {
        const color = WINGMAN_CONFIG.WINGMAN_COLORS[this.selectedWingman];
        this.createExplosion(enemy.position.clone(), color);
        
        this.scene.remove(enemy);
        this.enemies = this.enemies.filter(e => e !== enemy);
        this.updateEnemyCount();
      }
      
      updateEffects(delta) {
        const now = performance.now();
        
        // Update effects
        for (let i = this.effects.length - 1; i >= 0; i--) {
          const effect = this.effects[i];
          
          switch (effect.type) {
            case 'gatling': {
              effect.mesh.position.add(effect.direction.clone().multiplyScalar(effect.speed * delta));
              const dist = effect.mesh.position.distanceTo(effect.target);
              if (dist < 2) {
                this.scene.remove(effect.mesh);
                if (this.enemies.includes(effect.enemy)) {
                  this.destroyEnemy(effect.enemy);
                }
                this.effects.splice(i, 1);
              }
              break;
            }
            
            case 'beam': {
              const elapsed = now - effect.startTime;
              if (elapsed >= effect.duration) {
                this.scene.remove(effect.mesh);
                if (this.enemies.includes(effect.enemy)) {
                  this.destroyEnemy(effect.enemy);
                }
                this.effects.splice(i, 1);
              }
              break;
            }
            
            case 'lightning': {
              const elapsed = now - effect.startTime;
              if (elapsed >= effect.duration) {
                this.scene.remove(effect.mesh);
                // Destroy all chained enemies
                effect.enemies.forEach((enemy, idx) => {
                  setTimeout(() => {
                    if (this.enemies.includes(enemy)) {
                      this.destroyEnemy(enemy);
                    }
                  }, idx * 50);
                });
                this.effects.splice(i, 1);
              }
              break;
            }
            
            case 'missile': {
              const elapsed = now - effect.startTime;
              const progress = Math.min(elapsed / effect.flightTime, 1);
              
              // Arc trajectory
              const arcHeight = 5;
              const arcProgress = Math.sin(progress * Math.PI);
              
              const currentPos = new THREE.Vector3().lerpVectors(
                effect.startPosition,
                effect.target,
                progress
              );
              currentPos.y += arcProgress * arcHeight;
              
              effect.mesh.position.copy(currentPos);
              effect.mesh.lookAt(effect.target);
              
              if (progress >= 1) {
                this.scene.remove(effect.mesh);
                if (this.enemies.includes(effect.enemy)) {
                  this.destroyEnemy(effect.enemy);
                }
                this.effects.splice(i, 1);
              }
              break;
            }
          }
        }
        
        // Update explosions
        for (let i = this.explosions.length - 1; i >= 0; i--) {
          const exp = this.explosions[i];
          const elapsed = now - exp.startTime;
          const progress = elapsed / exp.duration;
          
          if (progress >= 1) {
            this.scene.remove(exp.mesh);
            this.explosions.splice(i, 1);
          } else {
            const scale = 0.1 + progress * 3;
            exp.mesh.scale.set(scale, scale, scale);
            exp.material.opacity = 1 - progress;
            exp.light.intensity = (1 - progress) * 10;
          }
        }
      }
      
      updateWingman(delta) {
        if (!this.isActive || !this.wingmanMesh) return;
        
        const now = performance.now();
        const elapsed = now - this.phaseStartTime;
        
        switch (this.phase) {
          case 'approach': {
            const progress = Math.min(elapsed / 1000, 1);
            const smoothProgress = this.smoothstep(progress, 0, 1);
            
            const spawnPos = new THREE.Vector3(0, WINGMAN_CONFIG.SPAWN_OFFSET_ABOVE, WINGMAN_CONFIG.SPAWN_OFFSET_BEHIND);
            this.wingmanMesh.position.lerpVectors(spawnPos, this.attackPosition, smoothProgress);
            
            if (progress >= 1) {
              this.phase = 'attack';
              this.phaseStartTime = now;
              this.executeAttack();
              this.updateStatus('ATTACKING');
            }
            break;
          }
          
          case 'attack': {
            if (elapsed > WINGMAN_CONFIG.ATTACK_DURATION) {
              this.phase = 'escape';
              this.phaseStartTime = now;
              this.updateStatus('DISENGAGING');
            }
            break;
          }
          
          case 'escape': {
            const progress = Math.min(elapsed / WINGMAN_CONFIG.ESCAPE_DURATION, 1);
            
            const escapePos = this.attackPosition.clone();
            escapePos.y += progress * 50;
            escapePos.z += progress * 30;
            this.wingmanMesh.position.copy(escapePos);
            this.wingmanMesh.rotation.x = -WINGMAN_CONFIG.ESCAPE_CLIMB_ANGLE;
            
            if (progress >= 1) {
              this.phase = 'idle';
              this.isActive = false;
              this.wingmanMesh.visible = false;
              this.cooldown = WINGMAN_CONFIG.TEAM_SPECIAL_COOLDOWN;
              this.updateStatus('STANDING BY');
              this.hideAttackType();
            }
            break;
          }
        }
      }
      
      smoothstep(x, min, max) {
        x = Math.max(0, Math.min(1, (x - min) / (max - min)));
        return x * x * (3 - 2 * x);
      }
      
      showMessage(text, color = 0x00ff88) {
        const msg = document.getElementById('hud-message');
        msg.textContent = text;
        msg.style.color = `#${color.toString(16).padStart(6, '0')}`;
        msg.classList.add('visible');
        setTimeout(() => msg.classList.remove('visible'), 1500);
      }
      
      showAttackType(text) {
        const elem = document.getElementById('hud-attack-type');
        elem.textContent = text;
        elem.classList.add('visible');
      }
      
      hideAttackType() {
        document.getElementById('hud-attack-type').classList.remove('visible');
      }
      
      updateStatus(status) {
        document.getElementById('wingman-status').textContent = status;
      }
      
      updateEnemyCount() {
        document.getElementById('enemy-count').textContent = this.enemies.length;
      }
      
      updateHUD() {
        const cooldownPercent = Math.max(0, ((WINGMAN_CONFIG.TEAM_SPECIAL_COOLDOWN - this.cooldown) / WINGMAN_CONFIG.TEAM_SPECIAL_COOLDOWN) * 100);
        const bar = document.getElementById('cooldown-bar');
        const label = document.getElementById('cooldown-label');
        
        bar.style.width = `${cooldownPercent}%`;
        
        if (this.isActive) {
          bar.style.background = '#ffaa00';
          label.textContent = 'TEAM SPECIAL [ACTIVE]';
        } else if (this.cooldown > 0) {
          bar.style.background = '#448844';
          label.textContent = `TEAM SPECIAL [${Math.ceil(this.cooldown / 1000)}s]`;
        } else {
          bar.style.background = '#00ff88';
          label.textContent = 'TEAM SPECIAL [READY]';
        }
        
        // Update trigger button
        const btn = document.getElementById('trigger-btn');
        btn.disabled = this.cooldown > 0 || this.isActive || this.enemies.length === 0;
      }
      
      selectWingman(index) {
        this.selectedWingman = index;
        
        // Update buttons
        document.querySelectorAll('.wingman-btn').forEach((btn, i) => {
          btn.classList.toggle('selected', i === index);
        });
        
        // Update name display
        document.getElementById('wingman-name').textContent = WINGMAN_CONFIG.WINGMAN_NAMES[index];
        document.getElementById('attack-hint').textContent = WINGMAN_CONFIG.ATTACK_NAMES[index];
      }
      
      setupEventListeners() {
        // Wingman selection
        document.querySelectorAll('.wingman-btn').forEach((btn, i) => {
          btn.addEventListener('click', () => this.selectWingman(i));
        });
        
        // Trigger button
        document.getElementById('trigger-btn').addEventListener('click', () => {
          this.triggerTeamSpecial();
        });
        
        // Reset button
        document.getElementById('reset-btn').addEventListener('click', () => {
          this.resetEnemies();
          this.showMessage('ENEMIES RESET', 0x4488ff);
        });
        
        // Keyboard shortcut
        window.addEventListener('keydown', (e) => {
          if (e.code === 'KeyQ') {
            this.triggerTeamSpecial();
          }
          if (e.code >= 'Digit1' && e.code <= 'Digit4') {
            this.selectWingman(parseInt(e.code.slice(-1)) - 1);
          }
        });
      }
      
      update(delta) {
        // Update cooldown
        if (this.cooldown > 0) {
          this.cooldown = Math.max(0, this.cooldown - delta * 1000);
        }
        
        // Rotate enemies
        this.enemies.forEach(enemy => {
          enemy.rotation.y += delta * 0.5;
        });
        
        // Update wingman
        this.updateWingman(delta);
        
        // Update effects
        this.updateEffects(delta);
        
        // Update HUD
        this.updateHUD();
      }
      
      animate() {
        requestAnimationFrame(() => this.animate());
        
        const now = performance.now();
        const delta = Math.min((now - this.lastTime) / 1000, 0.1);
        this.lastTime = now;
        
        this.update(delta);
        this.renderer.render(this.scene, this.camera);
      }
      
      onResize() {
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;
        
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
      }
    }

    // ========================================================================
    // INITIALIZE DEMO
    // ========================================================================
    window.addEventListener('DOMContentLoaded', () => {
      const container = document.getElementById('game-canvas');
      const demo = new WingmanDemo(container);
    });
  </script>
</body>
</html>
